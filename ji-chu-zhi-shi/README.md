---
description: >-
  面试中应该知道的基础知识，包括操作系统，编译，网络等方面的基础知识，不会深入但是为了面试和IT素养有必要了解；另外也会收罗一些JAVA语言相关的问题；最后推荐了一些公开课。
---

# 基础知识

## 网络层次划分／TCP／IP协议、三次握手和四次握手／进程与线程／进程调度算法／死锁／高速缓存Cache／最近最久未使用置换算法LRU的JAVA实现

**网络层次划分**  


为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。

除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/jYWFficmyzX7eLGAy7SGcsNjlWuIZXvCabBhAw6wa6ejxibicrgichSBRzo5byjQ6oKnIRAQLxRFbrF7GC63QibX4FA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**TCP／IP协议、三次握手和四次握手**  


TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

TCP协议中有著名的三次握手和四次握手规则，如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_jpg/jYWFficmyzX7eLGAy7SGcsNjlWuIZXvCaz2iauXz2M5mmqsNYAbBBkYTFcsrDG7ULZLuX4jRFcZ6SiadgEWd7yFdQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

注：seq:"sequance"序列号；ack:"acknowledge"确认号；SYN:"synchronize"请求同步标志；；ACK:"acknowledge"确认标志"；FIN："Finally"结束标志。

TCP连接建立过程  
首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

TCP连接断开过程  
假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN\_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME\_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

为什么要三次握手？  
在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

为什么要四次握手？  
试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

**进程与线程**

**定义**

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程：当一个进程内有多个线程时，线程的程序是其所属进程的一部分，表示进程中的一个控制点，执行一系列的指令。同属一个进程的其他的线程共享进程所拥有的全部资源（包括地址空间）。它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源\(如程序计数器,一组寄存器和栈\)，因此，它的创建、撤销、切换所需要的时空开销比进程要小。线程的引入可进一步提高系统的并发性。

**区别**

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

调度分派：线程是可调度分派的工作单元，它包括处理器上下文环境和栈中自己的数据区域。线程顺序执行，并且可以中断，这样处理器可以转到另一个线程。在有线程的系统中，进程不再是可调度分派的工作单元。  
资源拥有：进程是一个或多个线程和相关资源的集合。线程基本不拥有资源，它的运行资源取决于其所属的进程。  
地址空间：不同进程的地址空间是相互独立的，而同一个进程的各线程共享同一地址空间。  
一个进程可包含一个或多个线程，反过来则不然。一个进程中的线程在另一个进程中时不可见的。  
通信关系：进程间的通信必须使用操作系统提供的进程间通信机制，而同一个进程中的各线程间可以通过直接读写数据段来进行通信。当然，同一个进程中的各线程间的通信也需要同步和互斥手段的辅助，以确保数据一致性。

**进程调度算法**

（1）先来先服务（FCFS，First-Come-First-Served）: 此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序来选择作业（或进程）。  
（2）短作业优先（SJF,Shortest Process Next）：这种调度算法主要用于作业调度，它从作业后备队列中挑选所需运行时间（估计值）最短的作业进入主存运行。  
（3）时间片轮转调度算法（RR，Round-Robin）：当某个进程执行的时间片用完时，调度程序便停止该进程的执行，并将它送就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片处理机执行时间。  
（4）高响应比优先（HRRN，Highest Response Ratio Next）: 按照高响应比（（已等待时间＋要求运行时间）/ 要求运行时间）优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行。  
（5）优先权\(Priority\)调度算法: 按照进程的优先权大小来调度，使高优先权进程得到优先处理的调度策略称为优先权调度算法。  
（6） 多级队列调度算法：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个子队列，所有的作业（或进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。

**死锁**

**什么是死锁**

在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。

**产生死锁的原因**

死锁产生的原因主要是：1、 系统资源不足；2、进程推进顺序非法。  
产生死锁有四个必要条件：  
（1）互斥：一个资源每次只能被一个进程使用；  
（2）不可抢占进程已获得的资源，在未使用完之前，不能强行剥夺；  
（3）占有并等待一个进程因请求资源而阻塞时，对已获得的资源保持不放；  
（4）环形等待若干进程之间形成一种首尾相接的循环等待资源关系。  
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

**如何避免死锁**

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

下面介绍几种常见的死锁解决方法：

设置加锁顺序  
当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：

![](https://mmbiz.qpic.cn/mmbiz_png/jYWFficmyzX7eLGAy7SGcsNjlWuIZXvCaFScxPhPJNoSxBKwS4gWLPlYrropYkFV0iaKKtn83jQY79P6L7sr77mw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C\(译者注：获取锁A是获取锁C的必要条件\)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。

按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。

加锁时限  
另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。

死锁检测

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。

下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

那么当检测出死锁时，这些线程该做些什么呢？

一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。

一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。  


**高速缓存Cache**

**Cache的原理**

Cache，即高速缓存，是介于CPU和内存之间的高速小容量存储器。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近CPU的频率。  
当CPU发出内存访问请求时，会先查看 Cache 内是否有请求数据。  
如果存在（命中），则直接返回该数据；  
如果不存在（失效），再去访问内存 —— 先把内存中的相应数据载入缓存，再将其返回处理器。  
提供“高速缓存”的目的是让数据访问的速度适应CPU的处理速度，通过减少访问内存的次数来提高数据存取的速度。

Cache 技术所依赖的原理是”程序执行与数据访问的局部性原理“，这种局部性表现在两个方面：  
时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。  
空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令或数据通常是顺序存放的。  
时间局部性是通过将近来使用的指令和数据保存到Cache中实现。空间局部性通常是使用较大的高速缓存，并将 预取机制 集成到高速缓存控制逻辑中来实现。

**Cache替换策略\(页面置换算法\)**

Cache的容量是有限的，当Cache的空间都被占满后，如果再次发生缓存失效，就必须选择一个缓存块来替换掉。常用的替换策略有以下几种：  
（1）最佳置换算法（Optimal）：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。  
（2）先进先出置换算法FIFO：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。  
（3）最近最久未使用置换算法LRU（Least Recently Used）：该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。  
（4）Clock置换算法：也叫最近未用算法NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。  
（5）最少使用置换算法LFU：该算法选择最近时期使用最少的页面作为淘汰页。  


**最近最久未使用的置换算法LRU的java实现**

之前面头条的暑期实习生时曾经考过这道题，因此这里整理一下。

**思路分析**

对一个Cache的操作无非三种：插入\(insert\)、替换\(replace\)、查找（lookup）。  
为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们使用 双向链表 连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。  
插入：当Cache未满时，新的数据项只需插到双链表头部即可。时间复杂度为O\(1\).  
替换：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可。时间复杂度为O\(1\).  
查找：每次数据项被查询到时，都将此数据项移动到链表头部。  
经过分析，我们知道使用双向链表可以保证插入和替换的时间复杂度是O\(1\)，但查询的时间复杂度是O\(n\)，因为需要对双链表进行遍历。为了让查找效率也达到O\(1\)，很自然的会想到使用 hash table 。

具体的实现代码如下：

```text
import java.util.*

class Node{
   int key;
   int value;
   Node pre;
   Node next;

   public Node(int kye,int value){
       this.key = key;
       this.value = value;
   }
}

public class LRUCache {
   int capacity;
   Map<Integer,Node> map = new HashMap<Integer,Node>();
   Node head = null;
   Node end = null;

   public LRUCache(int capacity){
       this.capacity = capacity;
   }

   public int get(int key){
       if(map.containsKey(key)){
           Node n = map.get(key);
           remove(n);
           setHead(n);
           return n.value;
       }
       return -1;
   }

   public void remove(Node n){
       if(n.pre != null){
           n.pre.next = n.next;
       }
       else{
           head = n.next;
       }

       if(n.next != null){
           n.next.pre = n.pre;
       }
       else{
           end = n.pre;
       }
   }

   public void setHead(Node n){
       n.next = head;
       n.pre = null;
       if(head!=null)
           head.pre = n;
       head = n;
       if(end == null){
           end = head;
       }
   }

   public void set(int key,int value){
       if(map.containsKey(key)){
           Node old = map.get(key);
           old.value = value;
           remove(old);
           setHead(old);
       }
       else{
           Node created = new Node(key,value);
           if(map.size() >= capacity){
               map.remove(end.key);
               remove(end);
               setHead(created);
           }
           else{
               setHead(created);
           }
           map.put(key,created);
       }
   }

}
```

对于上述代码的解释如下：

get：通过get方法得到一个页面之后，要将这个页面先从链表中进行删除，然后放入到链表的头部。  


remove：执行删除一个页面的操作，此时要判断删除的key是头部节点和尾部节点的两种情况。

setHead：设置头节点。要注意的情况是当链表为空时，要同时设置head和end的值

set：更新缓存，如果key已经存在，则进行替换并放到链表的头部，如果key不存在，则插入到链表中，此时又要区分缓存的容量是否已满两种情况。

**References**  


1、计算机网络基础知识总结：https://www.cnblogs.com/maybe2030/p/4781555.html  
2、多线程死锁的产生以及如何避免死锁：https://blog.csdn.net/ls5718/article/details/51896159  
3、操作系统面试知识点总结：https://blog.csdn.net/sunxianghuang/article/details/51883496  
4、设计并实现一个LRU Cache \(java\)：https://blog.csdn.net/maoyeqiu/article/details/50452870

