# Introduction

这本手册记录了面向面试的各种总结和心得，包括Leetcode题目，算法总结，系统设计，Behavior Questions， ToastMaster类似提升演讲的技巧等等，本人完全不是牛人，希望自己不要停止思考。

面试前不要忽视基本问题。

面试中：

1\) 注意题目的条件，比如给定一个“有序”数组；设计一个O\(logn\)的算法一般都是Binary Search；设计一个O\(nlogn\)的算法-很可能是在搜索树里进行分治法，或者是否对对数组用快排或者merge sort；无需担心额外空间-那么就应该考虑用额外空间来实现对事件的优化；数据规模大概是10000 - 那么说明O\(n^2\)的算法也是可以的等等。

2\) 没有思路的时候怎么办，首先可以给自己设计几个非常简单的测试用例，在最简单的情况下看如何求解这个问题，给自己提供思路；其次不要忽略暴力解法，暴力解法通常是思路的起点，暴力解法可以引申出优化的解法，理论上所有的问题都是存在暴力解法的；在脑海里遍历一下常见的算法思路，看看是否适用于这个问题，在脑海里遍历一下常见的数据结构进行辅助；看看是否可以用空间换时间-比如哈希表；想想是否可以对数据进行预处理 - 比如排序；然后在瓶颈处寻找答案，比如一个解法O\(ologn\) + O\(n^2\)两部分组成，显然应该在第二部分去着想问题等等。

3\) 实际代码过程中，注意极端条件的判断，比如Array为空，字符串为空，数量为0，指针为NULL等；注意代码规范，比如变量名的意义；注意一定程度上的模块化和和复用性



主要分为几个部分：

* Leetcode刷题，按照一个个小的tags来总结，总结出这些tags非常费脑经，有些题可以放在其中一类也可以另外一类，我们就根据理解把题放在最合适的tag下面，在解释的时候一般会提一下也属于别的tags。同时，不标注Easy，Medium和Hard （当然，主要的题目都是Easy+Medium以及各处收集到的变种面经题，有代表性的Hard题也会有小部分），这样做主要是为了更好地专注解题本身，不会联想到题目的难度而产生畏惧心理，我们觉得只要理解了题意和思路，再加上练习，90%的题目都是没有问题的（剩下的10%怎么办？世界上哪有面面俱到的事情呢，剩下的10%死记硬背或者干脆放弃吧，话说面试真遇到这些变态题说明面试官十有八九在刁难你，就算咬牙做出来了，也很可能因为别的原因通不过整个面试）
* 系统设计
* 非面试问题的准备
* 演讲能力的提升

白板，collabedit，coderpad的联系，自己创建test cases。

在网上看到的别人分享的刷题办法，我自己改了一点文字：

> 刷题第一遍：

> 1）LeetCode按类型刷，自己总结类型/结合九章算法的大纲；

> 2）刷题过程中遇到对应的Data structure/Algrothms，补相关知识，然后刷对应的算法题目来增强；

> 3）Easy 练手，主攻Medium；

> 刷题第一遍的遇到的问题：

> 1）Easy 勉强能做出来，Medium靠答案，

> 解决办法：Easy刷熟练，Medium第一次刷，不会的话可以看答案

> 2）有的题目有思路但是写不出代码

> 解决办法：跟着人家的讲解一个样例一个样例的走，然后看懂样例运行步骤之后自己写代码；

> 3）有的算法看答案也看不懂

> 看适合自己的视频讲解

> 刷题第二遍以后，稍微顺利一些的时候：应该每一道题目都应该当做自己在面试，需要多总结多记笔记

> 1）先分析general情况，拿test case 走一遍，理清思路；

> 2）处理corner case（对于corner case要多记笔记）；

> 3\) 分析自己写的时间复杂度和空间复杂度的效率问题；

> 4）接着想是否可以有更好的优化算法；

> 5）对照其他人的答案，学习更优化的算法代码；

> 如何检查自己的刷题效果：

> 参加Leetcode的Contest和Mock Interview，要做到10~15min的easy难度的题搞定，Medium难度的题目10~15分钟有思路，30~40min写出来代码；

> 看《一亩三分地》的面经；

> -----------------------------------------------------------------

> leetcode刷300题就够用了，一定要熟悉自己的项目，把面试官可能问到的问题都想到回答一下

> 将leetcode的题目解析放到自己github上，；

> 解题思路 + code + 注释（分析时间空间复杂度）+同一道题目有两种解法+两种版本的代码（Java/python）



