# Introduction

这本手册记录了面向面试的各种总结和心得，包括Leetcode题目，算法总结，系统设计，Behavior Questions， ToastMaster类似提升演讲的技巧等等，本人完全不是牛人，希望自己不要停止思考。

面试前不要忽视基本问题。

> **舒适区／学习区／焦虑区**。你看着一道题不会打开参考程序看一行抄一行，感觉自己好像理解了这道题，全程非常舒适然而效果不大。再看到这道题你仍然可能和没做过一样，这就是舒适区学习的情况。你看着一道题冥思苦想不得解，烦躁到不行然后不想再刷题就是用力过猛。一股脑从舒适区冲到焦虑区然后弹回舒适区不再敢迈出学习的脚步。  
>   
>   
> 真正有效的**学习区训练**是你看完一道题不会解，花时间看答案把答案理解透。然后回到你的答题界面克服一定的不舒适感把答案写出来。这种方式能够保持合适的节奏进行刷题，在进度和效果之间找到合适的平衡点。

> **要刷到什么水平？**
>
> 大家很爱问一个问题，到底刷到什么水平能拿offer。我试着以我的理解来回答下这个问题。单说以找工作为目标的刷题，我把刷题分为4个阶段：  
>
> 1.      不知道怎么刷题，对很多概念比如Big O， DP都陌生。每天纠结到底是看那个算法书/资料入门快。  
>
> 2.      在一个良好的IDE里，做Medium题目只要愿意想一般都能做出来，做不出来看答案也就懂了。Hard也能做出不少。除了有些复杂算法还在消化中，算法上基本已经入门。但脱离IDE写代码，就有点发怵。函数signature甚至函数名都老记错。搞个string操作还得Google一下API。非常依赖自动补全。很多新人以及多年经验的老人，可能都处于这个阶段。  
>
> 3.      除了偶尔遇到个Hard题得想很久，基本平时刷LC非常comfortable。同时能非常comfortable的在白板或者LC等网站的网页简单IDE里写代码。写代码过程中不需要Google函数用法。不依赖自动补全。而且甚至觉着这么写比在IDE里还舒服。  
>
> 4.      在3的基础上，一般题目都是20分钟一道，写完基本扫一下一检查就可以bug-free。Hard题噼里啪啦码一堆，不管逻辑再混乱，心里非常清楚自己码的是什么，复杂度多少，有没有优化潜力。且非常自信自己码的是对的。对于一次提交就AC是自己的基本要求。对参加LC contest（contest里都要求一次提交就AC，否则罚时）等业余竞赛比较comfortable。
>
>   
> 以我理解：刷到3就可以去面试了。较大概率拿下[Amazon](http://https//www.amazon.com/b?_encoding=UTF8&tag=1point3acres-20&linkCode=ur2&linkId=89c11e2c5b86155c5422f19cca1e9880&camp=1789&creative=9325&node=5) MS等二线公司offer。刷到4去面一线公司\(FLGUAirPS...\)，基本也有较大概率成功。当然因为这种问题本来就不会有真理解，我的回答仅供参考。
>
>   
> **怎么刷题？**
>
> 今天谈的是进阶刷题tips，所以不谈1到2的过程，虽然这个过程是一个非常重要的质的飞跃。今天**主要谈2, 3如何到4 和 4以后如何准备最终的面试**。
>
> **2到3**：2到3是比较容易的，这个就是强迫自己在白板或者notepad这种文本编辑器里写代码，练多了就适应了。但头几次肯定会老去翻API什么的。但是人只有在被pushed out of your comfortable zone，才能提高。**你不适的感觉，就是提高的感觉**。  
> **3到4**:这里就需要提高自己的要求。当你觉着AC一题不是很难的事情时，将要求提高到一次提交必须AC。最好是编译错误都不要有，甚至连调试都不调试，甚至连人脑检查都不检查。终极状态就是噼里啪啦敲完一道题二话不说直接点submit，然后就AC 。这个要求确实太夸张，我自己也做不到\(做到几次也是纯运气\)。但这个要求其实合理：当你面试时，你在白板上写，写完之后，面试官很可能就立刻开始给你指bug了，你这时有的bug，都算bug！这里有一个面试技巧，面试时，在写完最后一句话前，最好做个大停顿，过一下之前写的，快速检查下。当然你嘴上可以给面试官解释你现在是在做最终检查，不是说卡住不会了。提高要求后，就是强迫自己每题达到要求。脑子里一定要认为，只有一次提交AC才算过，否则这题就算挂了。这又一次把自己从comfortable zone里push出来。但仍然那句话，**你不适的感觉，就是提高的感觉**。当然更高要求自己只是第一步。更要讲究方法。所以还是要学会总结。我曾经花过一整天时间总结二分查找。关键是+1 -1，上限，下限如何处理。这个总结完之后，再遇到二分题，最代码质量明显提高，随之而来的一个必然提升就是自己对二分题目的信心。以前见到二分特别闹心，生怕自己犯上下限+1 -1错误。现在再见二分都是长舒一口气，送分题来了！按这个要求刷100道题，coding的提高是可以感觉到的。有些很复杂的逻辑，以前写完觉着肯定会有bug的，现在就会很惊讶的发现居然写完就是对的。一次两次以为自己运气好，之后就会明白可能是自己水平真的提高了。  
> **4到面试。**到4的同学，基本属于刷题刷的很好的了，直接去面一线公司，大概率可能都能过，但为了保险，做到双杀，N杀，甚至All kill来增加自己offer谈判筹码，还可以再做一些强化：面试前一两周要做的就是，看题。就是只看题目，想解法，但不用写。题分两种，一种是考思维的题（比如很多贪心，你能想到如何去贪心，代码就几行）。还有一种是考实现的，（比如链表指针操作的题）。两种都考的归到考实现的那类。对于考思维的题，看5道10道动手做一道，确定自己水平没问题，保持下手感即可。对于考实现的题，最好尽量都再做一遍。那你问为啥不所有题都再做一遍？因为时间不够啊，最后两周，你要么选择刷几十道题，要么选择看几百道题（+刷若干题保持手感），这种情况选后者（别忘了你已经在4这个阶段了，对自己coding水平应该不存在怀疑了）。看题的一个原因是追求coverage，refresh下以前刷题的记忆，增大面试碰原题几率。而更重要的目的是，看题一定要看别人的解法，然后准备几个不同的解法。总之就是**一题多解:**    
>
> - 一定要知道 这题“标准解法”是什么。这个可以看LC Discuss里top voted那些或者其它相关文章。这个可能比你当时刷题的解法好，也可能烂。但你要知道。有些面试官他出题前，他脑海里有个标准做法。你的方法如果很与众不同，交流起来会很费劲，明明标准解法10分钟就能写清讲清，你的nb解法要花30分钟才能把他搞懂。你这轮本来能做3题，现在做2题。而且面试官可能对你的办法依然将信将疑，甚至觉着有问题。我个人教训就是以前面亚麻，明明很简单的一道题, 我平时刷都是10分钟秒杀的。面试那天那个面试官智商捉急（当然他可能觉着我表达捉急），硬是一直说不懂我的做法为啥是对的。。。最后折腾了30分钟，他说你别用你做法了，我提示个你做，我心想凭什么啊，很抵触的去follow他的提示，结果我也听不懂他在说啥。。然后结果可想而知。回来扫了眼LC，发现他提示的就是大家标准做法。而我的做法很小众。    
>
> -  一定要知道一个interview-friendly的解法。你刷题的解法或者标准解可能都不是你能在面试45分钟内写出来的。知道一个实现简单，思路更直白更好记的interview-friendly解很重要。刷题时一定要脑子里蹦根弦，想想你现在写的代码你面试时45分钟能不能bug free写出来？如果不能，找一个能的做为此题的面试解。举个例子，你做LC Reverse Pairs可能是用自己实现一个特殊的BST做的。但它也可以用merge-sort思路实现。那你面试一定要用后者。你如果当时刷过了，不回头看一下别人的做法，面试时真去自己实现BST去了，那很可能就挂在实现BST的增删查改上了。    
>
> - 锦上添花的话，考虑准备一个表演解。就是这个解与众不同，而且也是interview-friendly并且能当场讲清楚的。目的就是impress的面试官。同时让他觉着你没见过这题，临时想的。一个例子就是Deserialize/Serializetree。这个自由度很高，你可以用一个与众不同但也很简单清晰的做法来让面试官眼前一亮。



面试中：

1\) 注意题目的条件，比如给定一个“有序”数组；设计一个O\(logn\)的算法一般都是Binary Search；设计一个O\(nlogn\)的算法-很可能是在搜索树里进行分治法，或者是否对对数组用快排或者merge sort；无需担心额外空间-那么就应该考虑用额外空间来实现对事件的优化；数据规模大概是10000 - 那么说明O\(n^2\)的算法也是可以的等等。

2\) 没有思路的时候怎么办，首先可以给自己设计几个非常简单的测试用例，在最简单的情况下看如何求解这个问题，给自己提供思路；其次不要忽略暴力解法，暴力解法通常是思路的起点，暴力解法可以引申出优化的解法，理论上所有的问题都是存在暴力解法的；在脑海里遍历一下常见的算法思路，看看是否适用于这个问题，在脑海里遍历一下常见的数据结构进行辅助；看看是否可以用空间换时间-比如哈希表；想想是否可以对数据进行预处理 - 比如排序；然后在瓶颈处寻找答案，比如一个解法O\(ologn\) + O\(n^2\)两部分组成，显然应该在第二部分去着想问题等等。

3\) 实际代码过程中，注意极端条件的判断，比如Array为空，字符串为空，数量为0，指针为NULL等；注意代码规范，比如变量名的意义；注意一定程度上的模块化和和复用性



主要分为几个部分：

* Leetcode刷题，按照一个个小的tags来总结，总结出这些tags非常费脑经，有些题可以放在其中一类也可以另外一类，我们就根据理解把题放在最合适的tag下面，在解释的时候一般会提一下也属于别的tags。同时，不标注Easy，Medium和Hard （当然，主要的题目都是Easy+Medium以及各处收集到的变种面经题，有代表性的Hard题也会有小部分），这样做主要是为了更好地专注解题本身，不会联想到题目的难度而产生畏惧心理，我们觉得只要理解了题意和思路，再加上练习，90%的题目都是没有问题的（剩下的10%怎么办？世界上哪有面面俱到的事情呢，剩下的10%死记硬背或者干脆放弃吧，话说面试真遇到这些变态题说明面试官十有八九在刁难你，就算咬牙做出来了，也很可能因为别的原因通不过整个面试）
* 系统设计
* 非面试问题的准备
* 演讲能力的提升

白板，collabedit，coderpad的联系，自己创建test cases。

在网上看到的别人分享的刷题办法，我自己改了一点文字：

> 刷题第一遍：

> 1）LeetCode按类型刷，自己总结类型/结合九章算法的大纲；

> 2）刷题过程中遇到对应的Data structure/Algrothms，补相关知识，然后刷对应的算法题目来增强；

> 3）Easy 练手，主攻Medium；

> 刷题第一遍的遇到的问题：

> 1）Easy 勉强能做出来，Medium靠答案，

> 解决办法：Easy刷熟练，Medium第一次刷，不会的话可以看答案

> 2）有的题目有思路但是写不出代码

> 解决办法：跟着人家的讲解一个样例一个样例的走，然后看懂样例运行步骤之后自己写代码；

> 3）有的算法看答案也看不懂

> 看适合自己的视频讲解

> 刷题第二遍以后，稍微顺利一些的时候：应该每一道题目都应该当做自己在面试，需要多总结多记笔记

> 1）先分析general情况，拿test case 走一遍，理清思路；

> 2）处理corner case（对于corner case要多记笔记）；

> 3\) 分析自己写的时间复杂度和空间复杂度的效率问题；

> 4）接着想是否可以有更好的优化算法；

> 5）对照其他人的答案，学习更优化的算法代码；

> 如何检查自己的刷题效果：

> 参加Leetcode的Contest和Mock Interview，要做到10~15min的easy难度的题搞定，Medium难度的题目10~15分钟有思路，30~40min写出来代码；

> 看《一亩三分地》的面经；

> -----------------------------------------------------------------

> leetcode刷300题就够用了，一定要熟悉自己的项目，把面试官可能问到的问题都想到回答一下

> 将leetcode的题目解析放到自己github上，；

> 解题思路 + code + 注释（分析时间空间复杂度）+同一道题目有两种解法+两种版本的代码（Java/python）



