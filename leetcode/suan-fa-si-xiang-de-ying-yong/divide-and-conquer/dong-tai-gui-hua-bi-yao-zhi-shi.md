# 动态规划必要知识

## **自底向上和自顶向下**

#### **自底向上 bottom up**：

> 自底向上就是已经**知道了所有递归边界**，把所有可能的状态都算出来。基本步骤是一个拓扑排序的过程，从所有递归边界出发，当一个状态被所有可能的下层状态更新后，就用这个状态去更新后面的状态。**直到所求的状态被彻底更新完成为止。**

这段话，就是：**从初始已知的状态出发，向外拓展，最后到达目标状态。**

我们用自底向上实现这个题目就是：

![](http://image99.360doc.com/DownloadImg/2016/09/0613/79485982_2)

#### **自顶向下 top down：**

> 自顶向下就是不考虑整个图结构，直接从**要求的状态开始展开式子**，如果式子中的某个状态的值还不清楚，就递归的从这个状态展开。递归结束后式子中的状态都被对应的值替换了，所求状态自然也就清楚了。

也就是：**从最终状态开始，找到可以到达当前状态的状态，如果该状态还没处理，就先处理该状态。**

自顶向下通常使用递归实现，自顶向下的动态规划通常又有另外一个形象名字，叫做“记忆化搜索”。因为我们会去保存那个状态。

上面的题目如果使用自顶向下的套路，实现为：

![&#x5957;&#x8DEF;&#xFF0C;&#x8BA9;&#x4F60;&#x66F4;&#x597D;&#x5730;&#x7406;&#x89E3;&#x52A8;&#x6001;&#x89C4;&#x5212;](http://image99.360doc.com/DownloadImg/2016/09/0613/79485982_3)

我们要求f\[n\]直接就从f\[n\]开始寻找答案。

总结：

自顶向下，自底向上，只是动态规划实现的套路而已。复杂度并没有多大的变化。（事实上大多时候用自顶向下复杂度会更低，因为可以过滤掉更多无用的状态；不过自底向上可以避免爆栈问题，而且实现往往实现更为简单。）**选择哪一个还是要根据题目而定，没有哪一个绝对地好。**我们再来回顾一下这两个的特点。

自底向上：**从初始已知的状态出发，向外拓展，最后到达目标状态。**

自顶向下：**从最终状态开始，找到可以到达当前状态的状态，如果该状态还没处理，就先处理该状态。**

