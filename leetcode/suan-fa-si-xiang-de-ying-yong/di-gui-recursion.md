# 递归Recursion

递归的基本思想是**广义地**把规模大的问题转化为**规模小的相似的**子问题或者相似的子问题集合来解决。广义针对规模的，规模的缩小具体可以是指递归函数的参数，也可以是其参数之一。相似是指解决大问题的方法和解决小问题的方法往往是同一个方法，还可以是指解决子问题集的各子问题的方法是同一个方法。解决大问题的方法可以是由解决次规模问题的方法和解决剩余部分的方法组成，也可以是由一系列解决次规模问题的方法组成。

 用“递归”这个词，其实**递归可以是“有去有回”，也可以是“有去无回”。**但其**根本是“由大往小地去，由近及远地去”。“递”是必需，“归”并非必需，**依赖于要解决的问题，**有的需要去的路上解决，有的需要回来的路上解决。**有递无归的递归其实就是我们很容易理解的一种分治思想。

递归程序可以描述为以下几种：

第一种，规模大转化为规模小，这个是核心思想，但递归并非只做这步转化，而是把规模大的问题分解为规模小的子问题，和可以在子问题可以得到解决的基础上其它的剩余的可以自行解决的部分。后半部分是“归”的精髓，是实际解决问题的过程，可以表示为： 递　+　结束条件　＋　归

```java
function recursion(大规模) {
    if (end_condition) {
        end;
    } else {//先将问题全部描述展开，再由尽头“归”回来依次解决每步中剩余部分的问题
        recursion(小规模);     //go;
        solve;                //back;
    }
}
```

第二种，跟上面的结构类似，在“递”的过程中就解决该步中可自行解决的剩余部分，这样的做法比如二叉树的先序。

```java
function recursion(大规模) {
    if (end_condition) {
        end;
    } else {//在将问题转换为子问题描述的每一步，都解决该步中剩余部分的问题。
        solve;                //back;
        recursion(小规模);     //go;
    }
}
```

第三种，递归可能没有“归”，只有“递”（分治）的情况，这时候递归也许可以既不需要在“归”的路程上解决问题，也不需要在“递”的路程上解决问题。这时候，递归的分治思想不一定是要把问题规模递归到最小，而是把问题递归来穷举其所有的情形，这时候通常递归的思想体现在嵌套循环上面（不确定数量的嵌套循环），这时候递归函数的参数有一定的设计要求，即便递归到了尽头，规模也没有变小，但是列举了所有的情形来分别递归。

```java
recursion() {
    if (end_condition) {
        solve;
    } else {//在将问题转换为子问题描述的每一步，都解决该步中剩余部分的问题。
        for () {
            recursion();     //go; }
        }
    }
}
```



