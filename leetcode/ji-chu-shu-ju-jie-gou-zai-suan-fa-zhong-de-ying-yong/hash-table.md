# Hash Table

## 500 - Keyboard Row

### 原题概述

Given a List of words, return the words that can be typed using letters of **alphabet** on only one row's of American keyboard like the image below.  


![American keyboard](https://leetcode.com/static/images/problemset/keyboard.png)

**Example 1:**  


```text
Input: ["Hello", "Alaska", "Dad", "Peace"]
Output: ["Alaska", "Dad"]
```

**Note:**  


1. You may use one character in the keyboard more than once.
2. You may assume the input string will only contain letters of alphabet.

### 题意和分析

检查一个字符串数组里面的所有字符串，返回一些字符串，这些字符串只用键盘中的一行就可以写出来。可以用regex或者hashmap。把在同row的char标记成同index存在HashMap中；然后判定word中的每一个char是否有相同的index；Time Complexity: O\(n\), n是words中每个word的char总和.

### 代码

```java
class Solution {
    public String[] findWords(String[] words) {
        if (words == null || words.length == 0) {
            return words;
        }
        String[] keyboard = {"qwertyuiop","asdfghjkl","zxcvbnm"};
        HashMap<Character, Integer> hm = new HashMap<>();
        for (int i = 0; i < keyboard.length; i++) {
            for (char c : keyboard[i].toCharArray()) {
                hm.put(c, i);//每一列的i不一样0,1,2
            }
        }
        List<String> result = new ArrayList<>();
        for (String word : words) {
            if (word == "") {
                continue;
            }
            int index = hm.get(word.toLowerCase().charAt(0));//查一下第一个字符的index
            //检查字符串里面所有字符的index
            for (char c : word.toLowerCase().toCharArray()) {
                if (index != hm.get(c)) {//如果有字符的index和第一个字符不相同
                    index = -1;
                }
            }
            if (index != -1) {
                result.add(word);
            }
        }
        return result.toArray(new String[0]);//new String[0]确定是字符串数组
    }
}
```

## 463 - Island Perimeter

### 原题概述

You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically \(not diagonally\). The grid is completely surrounded by water, and there is exactly one island \(i.e., one or more connected land cells\). The island doesn't have "lakes" \(water inside that isn't connected to the water around the island\). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

**Example:**

```text
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:

```

![](../../.gitbook/assets/image%20%2828%29.png)

### 题意和分析

给一个矩形，里面的小格子是正方形，1代表陆地，0代表水，整个矩形边不超过100，没有湖，需要求出陆地周长。对整个二维数组遍历，每当遍历到一个陆地1时，同时判断下这块陆地的右边和下边看是否也是陆地，如果是就说明有neighbors，最后周长计算为land \* 4 - neighbors \* 2。时间O\(m \* n\)，空间O\(1\)。

### 代码

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int lands = 0, neighbors = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    lands++;
                    if (i < grid.length - 1 && grid[i+1][j] == 1) {//下方是陆地
                        neighbors++;
                    }
                    if (j < grid[0].length - 1 && grid[i][j+1] == 1) {//右边是陆地
                        neighbors++;
                    }
                }
            }
        }
        return lands * 4 - neighbors * 2;
    }
}
```

## 389 - Find the Difference

### 原题概述

Given two strings **s** and **t** which consist of only lowercase letters.

String **t** is generated by random shuffling string **s** and then add one more letter at a random position.

Find the letter that was added in **t**.

**Example:**

```text
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

### 题意和分析

给一个字符串s，根据s把里面的字符都shuffle一下然后随机加一个字符然后生产t，找到刚才随机加上的字符。

首先位操作的XOR可以去掉重复，因为自己和自己异或等于0；另外也可以计算两个字符串char codes的差距，然后转换成char即可，时间O\(n\)，空间O\(1\)。

> char b = 'a'+18; //因为char本身在码表中可以用数字表示的，然后运算玩之后还是char，应该输出s 
>
> char a = 'a'; //这个定义就是错误的。 
>
> char b = a + 18; // 这样也是错的，因为JVM运算完后不知道结果是多少，所以会提示损失精度的错误，关于一个类型变量值的问题。

### 代码

XOR

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int len = t.length();
        char ch = t.charAt(len - 1);//初始化，注意长字符串t最后多出来的那位为初始值，因为下面的循环要保证每个元素都遍历到
        for (int i = 0; i < len - 1; i++) {//i < len -1，短的字符串不越界
            ch ^= s.charAt(i);
            ch ^= t.charAt(i);
        }
        return ch;
    }
}
```

XOR更好理解的做法，需要一点额外空间，两个串合在一起然后XOR，最后剩余的就是多出来的字符

```java
class Solution {
    public char findTheDifference(String s, String t) {
        String merge = s + t;
        char ch = 0;//初始化，这里表示ch的初始值为空格' '，P.S.，用ch != '\0'判断字符是否为空格
        for (int i = 0; i < merge.length(); i++) {
            ch ^= merge.charAt(i);//等于 ch = (char) (ch ^ merge.charAt(i));
        }
        return ch;
    }
}
```

int和char转换的做法

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int len = s.length();
        int charCode = t.charAt(len);//初始化为长的字符串最后一位，因为下面的循环要保证每个元素都遍历到
        for (int i = 0; i < len; i++) {
            charCode -= s.charAt(i);
            charCode += t.charAt(i);
        }
        return (char)charCode;
    }
}
```

## 347 - Top K Frequent Elements

### 原题概述

Given a non-empty array of integers, return the **k** most frequent elements.

For example,  
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

**Note:**   


* You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
* Your algorithm's time complexity **must be** better than O\(n log n\), where n is the array's size.

### 题意和分析

高频题，给一个非空的整数数组和一个总是有效的的整数k，返回前k个最多出现的元素。可以用HashMap来做桶排序，TreeMap和最大堆来做。

### 代码

用最大堆，把数字和其频率放到HashMap中，然后把map的entry放到maxHeap中，从最顶上拿走k个数字的entry然后相对应的keys就是最高频率的k个数字。

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);//原数组的元素为key，出现次数为value
        }

        //利用最大堆
        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = new PriorityQueue<>((a,b)->(b.getValue() - a.getValue()));
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            maxHeap.add(entry);
        }

        List<Integer> result = new ArrayList<>();
        while (result.size() < k) {
            Map.Entry<Integer, Integer> entry = maxHeap.poll();//取出顶部元素并删除
            result.add(entry.getKey());
        }
        return result;
    }
}
```

HashMap桶排序的做法，在建立好数字和其出现次数的映射后利用桶排序取k个最频繁的数字

```java
class Solution {    
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);//原数组的元素为key，出现次数为value
        }

        //创建一个放buckets的list
        List<Integer>[] bucket = new List[nums.length + 1];//如果只有一个元素，那么也需要一个index为1的bucket
        for (int num : map.keySet()) {
            int freq = map.get(num);
            if (bucket[freq] == null) {//没有这个桶，就加一个
                bucket[freq] = new LinkedList<>();
            }
            bucket[freq].add(num);//在每个桶加上各自的元素
        }

        List<Integer> result = new LinkedList<>();
        for (int i = bucket.length - 1; i > 0 && k > 0; i--) {//从做到右取n个
            if (bucket[i] != null) {//只要出现过
                List<Integer> list = bucket[i];
                result.addAll(list);
                k -= list.size();
            }
        }
        return result;
    }
}
```

利用TreeMap自动排序

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);//原数组的元素为key，出现次数为value
        }

        //利用treeMap自动排序
        TreeMap<Integer, List<Integer>> freqMap = new TreeMap<>();
        for (int num : map.keySet()) {
            int freq = map.get(num);
            if (!freqMap.containsKey(freq)) {
                freqMap.put(freq, new LinkedList<>());
            }
            freqMap.get(freq).add(num);
        }

        List<Integer> result = new ArrayList<>();
        while (result.size() < k) {//取前k位
            Map.Entry<Integer, List<Integer>> entry = freqMap.pollLastEntry();
            result.addAll(entry.getValue());
        }
        return result;
    }
}
```

## 349 - Intersection of Two Arrays

### 原题概述

Given two arrays, write a function to compute their intersection.

**Example:**  
Given nums1 = `[1, 2, 2, 1]`, nums2 = `[2, 2]`, return `[2]`.

**Note:**  


* Each element in the result must be unique.
* The result can be in any order.

### 题意和分析

有两个数组，找到他们交叉的部分（元素的个数），结果中的元素都是unique的，无关顺序。用两个set，第一个set存第一个数组的元素，然后第二个数组来检查是否有相同的元素，有的话就把这些元素存入到第二个set中，然后遍历第二个set将其中的元素作为整数数组返回，时间O\(n\)，空间O\(n\)。

### 代码

两个set

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> intersect = new HashSet<>();
        for (int i = 0; i < nums1.length; i++) {//把nums1的元素存储到第一个set中
            set1.add(nums1[i]);
        }
        for (int i = 0; i < nums2.length; i++) {//检查nums2的元素是否在第一个set中存在，存在就加入到第二个set中
            if (set1.contains(nums2[i])) {//有交叉
                intersect.add(nums2[i]);
            }
        }
        int[] result = new int[intersect.size()];//遍历把第二个set中的元素存到结果的array中
        int i = 0;
        for (int num : intersect) {
            result[i] = num;
            i++;
        }
        return result;
    }
}
```

双指针做法，只用一个set，将两个数组排序后用个指针分别判断大小，因为要排序，时间O\(nlogn\)，空间O\(n\)。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        int i = 0, j = 0;//双指针
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] < nums2[j]) {
                i++;
            } else if (nums1[i] > nums2[j]) {
                j++;
            } else {//相等
                set.add(nums1[i]);
                i++;
                j++;
            }
        }

        //将set中的元素存入到整数数组中
        int k = 0;
        int[] result = new int[set.size()];
        for (int num : set) {
            result[k] = num;
            k++;
        }
        return result;
    }
}
```

类似的方法，也可以用二分查找，将一个数组排序，然后用二分查找来遍历另外一个数组，看是否在第一个数组中存在，时间O\(nlogn\)，空间\(n\)。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set = new HashSet<>();
        Arrays.sort(nums1);

        for (int i = 0; i < nums2.length; i++) {
            if (binarySearch(nums1, nums2[i])) {
                set.add(nums2[i]);
            }
        }
        int[] result = new int[set.size()];
        int k = 0;
        for (int num : set) {
            result[k] = num;
            k++;
        }
        return result;
    }

    private boolean binarySearch(int[] nums, int n) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {//注意是地板除法，所以等于也是包含的，比如一个数的时候
            int mid = left + (right - left) / 2;
            if (nums[mid] < n) {//小于就不用再检查mid了，所以是mid+1
                left = mid + 1;
            } else if (nums[mid] > n) {//大于就不用再检查mid了，所以是mid-1
                right = mid - 1;
            } else {//等于
                return true;
            }
        }
        return false;
    }
}
```

## 242 - Valid Anagram

### 原题概述

Given two strings _s_ and _t_ , write a function to determine if _t_ is an anagram of _s_.

**Example 1:**

```text
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```text
Input: s = "rat", t = "car"
Output: false
```

**Note:**  
You may assume the string contains only lowercase alphabets.

**Follow up:**  
What if the inputs contain unicode characters? How would you adapt your solution to such case?

### 题意和分析

给两个字符串，判断二者是否打乱顺序组成的Anagram。这道题如果先排序再比较是否一样，复杂度为O\(nlogn\)；如果用XOR来消除的话，又不能排除aa和bb这样也能等于0的情况。因为字符可以用数字来表示，所以一个loop分别加减二者的所有字符的值，看是否有的字符为不为0即可，时间O\(n\)，空间创建了两个数组，O\(n\)。

### 代码

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s == null && t == null) {
            return true;
        } else if (s == null || t == null) {
            return false;
        } else if (s.length() != t.length()) {
            return false;
        }

        char[] char1 = s.toCharArray();
        char[] char2 = t.toCharArray();

        int[] alphabet = new int[26];//因为题目说了都是小写字母，所以最多26个
        for (int i = 0; i < char1.length; i++) {
            //在数组的特定的位置进行加减
            alphabet[char1[i] - 'a']++;
            alphabet[char2[i] - 'a']--;
        }

        for (int num : alphabet) {
            if (num != 0) {//只要找到一个部位0的表示至少有一个不相同的字符
                return false;
            }
        }
        return true;
    }
}
```

题目有追问，如果字符串中有unicode应该怎么调整，在Java中，Unicode 可以用一个字符来表示\(BMP, Basic Multilingual Plane\)，也可以用两个字符来表示\(high surrogate\)。我们可以用`String.codePointAt(int index)`这个方法来得到Unicode的整数表示法，其中index是哈希表中的key，另外可以用`Character.charCount(int code)`来得到在该位置有多少个characters被用到，从而正确地对index进行递增

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s == null && t == null) {
            return true;
        } else if (s == null || t == null) {
            return false;
        } else if (s.length() != t.length()) {
            return false;
        }

        Map<Integer, Integer> dict = new HashMap<>();//创建一个map来检查两个字符串的字符
        int index = 0;
        while (index < s.length()) {
            int charCode = s.codePointAt(index);//得到Unicode的整数的表达形式
            dict.put(charCode, dict.getOrDefault(charCode, 0) + 1);
            index += Character.charCount(charCode);//Unicode可以有一个或者两个字符的表达形式
        }
        index = 0;
        while (index < t.length()) {
            int charCode = t.codePointAt(index);
            int count = dict.getOrDefault(charCode, 0);//看看是否有同样的字符

            if (count == 0) {
                return false;
            } else {
                dict.put(charCode, count - 1);
            }

            index += Character.charCount(charCode);
        }
        return true;
    }
}
```

Java8开始有新的特性，可以用`Charsequence.copdpoints()`来简化代码

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s == null && t == null) {
            return true;
        } else if (s == null || t == null) {
            return false;
        } else if (s.length() != t.length()) {
            return false;
        }

        Map<Integer, Integer> dict = new HashMap<>();//创建一个map来检查两个字符串的字符
        s.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) + 1));
        t.codePoints().forEach(code -> dict.put(code, dict.getOrDefault(code, 0) - 1));

        for (int count : dict.values()) {
            if (count < 0) {
                return false;
            }
        }
        return true;
    }
}
```



